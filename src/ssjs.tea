let cssNoMeasurement = Set*([
    "animationIterationCount"
    "boxFlex"
    "boxFlexGroup"
    "boxOrdinalGroup"
    "columnCount"
    "fillOpacity"
    "flex"
    "flexGrow"
    "flexPositive"
    "flexShrink"
    "flexNegative"
    "flexOrder"
    "fontWeight"
    "lineClamp"
    "lineHeight"
    "opacity"
    "order"
    "orphans"
    "stopOpacity"
    "strokeDashoffset"
    "strokeOpacity"
    "strokeWidth"
    "tabSize"
    "widows"
    "zIndex"
    "zoom"
])
let cssPrefixes = ["-webkit-", "-moz-", "-ms-", "-o-", ""]
let prefixMap = ["userSelect"].reduce(
    (prefixes, name) => {
        ...prefixes
        [name]: cssPrefixes
    }
    {}
)

let cssValueString = (key, value) => {
    let type = typeof value
    if type == "function" {
        return value()
    }
    if type == "number" && cssNoMeasurement.has(key) == false {
        return "${value}px"
    }
    return value
}
let arrayify = (obj) => Object.keys(obj)
    .map((key) => {
        let mut value = obj[key]

        if typeof value == "object" && Array.isArray(value) == false {
            value = arrayify(value)
            return {key, value}
        }

        return {name: key, value}
    })

let renderText = (cssItem, options) => {
    let tab = options.tab.repeat(options.indent)
    let parts = []
    let {split} = options

    let {key, name, value} = cssItem

    if key != void {
        parts.push("${tab}${key}${split}{")
        for val in value {
            parts.push(
                renderText(
                    val
                    {...options, indent: options.indent + 1}
                )
            )
        }
        parts.push("${tab}}")
    }
    else {
        let displayName = name.replace(
            /[A-Z]/g
            (match) => "-${match.toLowerCase()}"
        )

        if Array.isArray(value) == true {
            for valueItem in value {
                let cssValue = cssValueString(name, valueItem)
                parts.push("${tab}${displayName}:${split}${cssValue};")
            }
        }
        else {
            let cssValue = cssValueString(name, value)
            let prefixes = prefixMap[name] ?? [""]

            for prefix in prefixes {
                parts.push("${tab}${prefix}${displayName}:${split}${cssValue};")
            }
        }
    }

    return parts.join(options.join)
}
renderText.min = (items) => items.map(
    (item) => renderText(
        item
        {
            split: ""
            join: ""
            tab: ""
            indent: 0
        }
    )
).join("")
renderText.normal = (items, tab = "    ") => items.map(
    (item) => renderText(
        item
        {
            split: " "
            join: "\n"
            tab
            indent: 0
        }
    )
).join("\n")

construct Sheet {
    new() => {
        #element = null
        #entries = []
        #attributes = {}
    }

    get attr() => #attributes

    addStyles(styles) => {
        #entries.push(...arrayify(styles))
    }

    attach(renderStyle = "normal") => {
        if #element != null {
            return
        }

        #element = document.createElement("style")
        for name, attrValue of #attributes {
            #element.setAttribute(name, attrValue)
        }
        #element.innerHTML = renderText[renderStyle](#entries)
        document.head.appendChild(#element)
    }

    render(renderStyle = "normal") => renderText[renderStyle](#entries)
}

export default {
    create: Sheet
}
